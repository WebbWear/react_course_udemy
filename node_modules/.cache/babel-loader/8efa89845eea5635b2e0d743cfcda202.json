{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/jeff/Code-learning/react-complete-guide/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jeff/Code-learning/react-complete-guide/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/jeff/Code-learning/react-complete-guide/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/jeff/Code-learning/react-complete-guide/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/jeff/Code-learning/react-complete-guide/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/jeff/Code-learning/react-complete-guide/node_modules/@babel/runtime/helpers/inherits\");\n\nvar UTIL = require('util'),\n    PATH = require('path'),\n    EOL = require('os').EOL,\n    Q = require('q'),\n    chalk = require('chalk'),\n    CoaObject = require('./coaobject'),\n    Opt = require('./opt'),\n    Arg = require('./arg'),\n    completion = require('./completion');\n/**\n * Command\n *\n * Top level entity. Commands may have options and arguments.\n *\n * @namespace\n * @class Cmd\n * @extends CoaObject\n */\n\n\nvar Cmd =\n/*#__PURE__*/\nfunction (_CoaObject) {\n  _inherits(Cmd, _CoaObject);\n\n  /**\n   * @constructs\n   * @param {COA.Cmd} [cmd] parent command\n   */\n  function Cmd(cmd) {\n    var _this2;\n\n    _classCallCheck(this, Cmd);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Cmd).call(this, cmd));\n\n    _this2._parent(cmd);\n\n    _this2._cmds = [];\n    _this2._cmdsByName = {};\n    _this2._opts = [];\n    _this2._optsByKey = {};\n    _this2._args = [];\n    _this2._api = null;\n    _this2._ext = false;\n    return _this2;\n  }\n\n  _createClass(Cmd, [{\n    key: \"_parent\",\n    value: function _parent(cmd) {\n      this._cmd = cmd || this;\n      this.isRootCmd || cmd._cmds.push(this) && this._name && (this._cmd._cmdsByName[this._name] = this);\n      return this;\n    }\n  }, {\n    key: \"name\",\n\n    /**\n     * Set a canonical command identifier to be used anywhere in the API.\n     *\n     * @param {String} name - command name\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    value: function name(_name) {\n      _get(_getPrototypeOf(Cmd.prototype), \"name\", this).call(this, _name);\n\n      this.isRootCmd || (this._cmd._cmdsByName[_name] = this);\n      return this;\n    }\n    /**\n     * Create new or add existing subcommand for current command.\n     *\n     * @param {COA.Cmd} [cmd] existing command instance\n     * @returns {COA.Cmd} new subcommand instance\n     */\n\n  }, {\n    key: \"cmd\",\n    value: function cmd(_cmd) {\n      return _cmd ? _cmd._parent(this) : new Cmd(this);\n    }\n    /**\n     * Create option for current command.\n     *\n     * @returns {COA.Opt} new option instance\n     */\n\n  }, {\n    key: \"opt\",\n    value: function opt() {\n      return new Opt(this);\n    }\n    /**\n     * Create argument for current command.\n     *\n     * @returns {COA.Opt} new argument instance\n     */\n\n  }, {\n    key: \"arg\",\n    value: function arg() {\n      return new Arg(this);\n    }\n    /**\n     * Add (or set) action for current command.\n     *\n     * @param {Function} act - action function,\n     *         invoked in the context of command instance\n     *         and has the parameters:\n     *                 - {Object} opts - parsed options\n     *                 - {String[]} args - parsed arguments\n     *                 - {Object} res - actions result accumulator\n     *         It can return rejected promise by Cmd.reject (in case of error)\n     *         or any other value treated as result.\n     * @param {Boolean} [force=false] flag for set action instead add to existings\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n\n  }, {\n    key: \"act\",\n    value: function act(_act, force) {\n      if (!_act) return this;\n      (!this._act || force) && (this._act = []);\n\n      this._act.push(_act);\n\n      return this;\n    }\n    /**\n     * Make command \"helpful\", i.e. add -h --help flags for print usage.\n     *\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n\n  }, {\n    key: \"helpful\",\n    value: function helpful() {\n      return this.opt().name('help').title('Help').short('h').long('help').flag().only().act(function () {\n        return this.usage();\n      }).end();\n    }\n    /**\n     * Adds shell completion to command, adds \"completion\" subcommand,\n     * that makes all the magic.\n     * Must be called only on root command.\n     *\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n\n  }, {\n    key: \"completable\",\n    value: function completable() {\n      return this.cmd().name('completion').apply(completion).end();\n    }\n    /**\n     * Allow command to be extendable by external node.js modules.\n     *\n     * @param {String} [pattern]  Pattern of node.js module to find subcommands at.\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n\n  }, {\n    key: \"extendable\",\n    value: function extendable(pattern) {\n      this._ext = pattern || true;\n      return this;\n    }\n  }, {\n    key: \"_exit\",\n    value: function _exit(msg, code) {\n      return process.once('exit', function (exitCode) {\n        msg && console[code === 0 ? 'log' : 'error'](msg);\n        process.exit(code || exitCode || 0);\n      });\n    }\n    /**\n     * Build full usage text for current command instance.\n     *\n     * @returns {String} usage text\n     */\n\n  }, {\n    key: \"usage\",\n    value: function usage() {\n      var res = [];\n      this._title && res.push(this._fullTitle());\n      res.push('', 'Usage:');\n      this._cmds.length && res.push(['', '', chalk.redBright(this._fullName()), chalk.blueBright('COMMAND'), chalk.greenBright('[OPTIONS]'), chalk.magentaBright('[ARGS]')].join(' '));\n      this._opts.length + this._args.length && res.push(['', '', chalk.redBright(this._fullName()), chalk.greenBright('[OPTIONS]'), chalk.magentaBright('[ARGS]')].join(' '));\n      res.push(this._usages(this._cmds, 'Commands'), this._usages(this._opts, 'Options'), this._usages(this._args, 'Arguments'));\n      return res.join(EOL);\n    }\n  }, {\n    key: \"_usage\",\n    value: function _usage() {\n      return chalk.blueBright(this._name) + ' : ' + this._title;\n    }\n  }, {\n    key: \"_usages\",\n    value: function _usages(os, title) {\n      if (!os.length) return;\n      return ['', title + ':'].concat(os.map(function (o) {\n        return \"  \".concat(o._usage());\n      })).join(EOL);\n    }\n  }, {\n    key: \"_fullTitle\",\n    value: function _fullTitle() {\n      return \"\".concat(this.isRootCmd ? '' : this._cmd._fullTitle() + EOL).concat(this._title);\n    }\n  }, {\n    key: \"_fullName\",\n    value: function _fullName() {\n      return \"\".concat(this.isRootCmd ? '' : this._cmd._fullName() + ' ').concat(PATH.basename(this._name));\n    }\n  }, {\n    key: \"_ejectOpt\",\n    value: function _ejectOpt(opts, opt) {\n      var pos = opts.indexOf(opt);\n      if (pos === -1) return;\n      return opts[pos]._arr ? opts[pos] : opts.splice(pos, 1)[0];\n    }\n  }, {\n    key: \"_checkRequired\",\n    value: function _checkRequired(opts, args) {\n      if (this._opts.some(function (opt) {\n        return opt._only && opts.hasOwnProperty(opt._name);\n      })) return;\n\n      var all = this._opts.concat(this._args);\n\n      var i;\n\n      while (i = all.shift()) {\n        if (i._req && i._checkParsed(opts, args)) return this.reject(i._requiredText());\n      }\n    }\n  }, {\n    key: \"_parseCmd\",\n    value: function _parseCmd(argv, unparsed) {\n      unparsed || (unparsed = []);\n      var i,\n          optSeen = false;\n\n      while (i = argv.shift()) {\n        i.indexOf('-') || (optSeen = true);\n\n        if (optSeen || !/^\\w[\\w-_]*$/.test(i)) {\n          unparsed.push(i);\n          continue;\n        }\n\n        var pkg = void 0,\n            cmd = this._cmdsByName[i];\n\n        if (!cmd && this._ext) {\n          if (this._ext === true) {\n            pkg = i;\n            var c = this;\n\n            while (true) {\n              // eslint-disable-line\n              pkg = c._name + '-' + pkg;\n              if (c.isRootCmd) break;\n              c = c._cmd;\n            }\n          } else if (typeof this._ext === 'string') pkg = ~this._ext.indexOf('%s') ? UTIL.format(this._ext, i) : this._ext + i;\n\n          var cmdDesc = void 0;\n\n          try {\n            cmdDesc = require(pkg);\n          } catch (e) {// Dummy\n          }\n\n          if (cmdDesc) {\n            if (typeof cmdDesc === 'function') {\n              this.cmd().name(i).apply(cmdDesc).end();\n            } else if (typeof cmdDesc === 'object') {\n              this.cmd(cmdDesc);\n              cmdDesc.name(i);\n            } else throw new Error('Error: Unsupported command declaration type, ' + 'should be a function or COA.Cmd() object');\n\n            cmd = this._cmdsByName[i];\n          }\n        }\n\n        if (cmd) return cmd._parseCmd(argv, unparsed);\n        unparsed.push(i);\n      }\n\n      return {\n        cmd: this,\n        argv: unparsed\n      };\n    }\n  }, {\n    key: \"_parseOptsAndArgs\",\n    value: function _parseOptsAndArgs(argv) {\n      var opts = {},\n          args = {},\n          nonParsedOpts = this._opts.concat(),\n          nonParsedArgs = this._args.concat();\n\n      var res, i;\n\n      while (i = argv.shift()) {\n        if (i !== '--' && i[0] === '-') {\n          var m = i.match(/^(--\\w[\\w-_]*)=(.*)$/);\n\n          if (m) {\n            i = m[1];\n            this._optsByKey[i]._flag || argv.unshift(m[2]);\n          }\n\n          var opt = this._ejectOpt(nonParsedOpts, this._optsByKey[i]);\n\n          if (!opt) return this.reject(\"Unknown option: \".concat(i));\n          if (Q.isRejected(res = opt._parse(argv, opts))) return res;\n          continue;\n        }\n\n        i === '--' && (i = argv.splice(0));\n        Array.isArray(i) || (i = [i]);\n        var a = void 0;\n\n        while (a = i.shift()) {\n          var arg = nonParsedArgs.shift();\n          if (!arg) return this.reject(\"Unknown argument: \".concat(a));\n          arg._arr && nonParsedArgs.unshift(arg);\n          if (Q.isRejected(res = arg._parse(a, args))) return res;\n        }\n      }\n\n      return {\n        opts: this._setDefaults(opts, nonParsedOpts),\n        args: this._setDefaults(args, nonParsedArgs)\n      };\n    }\n  }, {\n    key: \"_setDefaults\",\n    value: function _setDefaults(params, desc) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = desc[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var item = _step.value;\n          item._def !== undefined && !params.hasOwnProperty(item._name) && item._saveVal(params, item._def);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return params;\n    }\n  }, {\n    key: \"_processParams\",\n    value: function _processParams(params, desc) {\n      var notExists = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = desc[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var item = _step2.value;\n          var n = item._name;\n\n          if (!params.hasOwnProperty(n)) {\n            notExists.push(item);\n            continue;\n          }\n\n          var vals = Array.isArray(params[n]) ? params[n] : [params[n]];\n          delete params[n];\n          var res = void 0;\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = vals[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var v = _step3.value;\n              if (Q.isRejected(res = item._saveVal(params, v))) return res;\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return this._setDefaults(params, notExists);\n    }\n  }, {\n    key: \"_parseArr\",\n    value: function _parseArr(argv) {\n      return Q.when(this._parseCmd(argv), function (p) {\n        return Q.when(p.cmd._parseOptsAndArgs(p.argv), function (r) {\n          return {\n            cmd: p.cmd,\n            opts: r.opts,\n            args: r.args\n          };\n        });\n      });\n    }\n  }, {\n    key: \"_do\",\n    value: function _do(inputPromise) {\n      var _this3 = this;\n\n      return Q.when(inputPromise, function (input) {\n        return [_this3._checkRequired].concat(input.cmd._act || []).reduce(function (res, act) {\n          return Q.when(res, function (prev) {\n            return act.call(input.cmd, input.opts, input.args, prev);\n          });\n        }, undefined);\n      });\n    }\n    /**\n     * Parse arguments from simple format like NodeJS process.argv\n     * and run ahead current program, i.e. call process.exit when all actions done.\n     *\n     * @param {String[]} argv - arguments\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n\n  }, {\n    key: \"run\",\n    value: function run(argv) {\n      var _this4 = this;\n\n      argv || (argv = process.argv.slice(2));\n\n      var cb = function cb(code) {\n        return function (res) {\n          return res ? _this4._exit(res.stack || res.toString(), (res.hasOwnProperty('exitCode') ? res.exitCode : code) || 0) : _this4._exit();\n        };\n      };\n\n      Q.when(this.do(argv), cb(0), cb(1)).done();\n      return this;\n    }\n    /**\n     * Invoke specified (or current) command using provided\n     * options and arguments.\n     *\n     * @param {String|String[]} [cmds] - subcommand to invoke (optional)\n     * @param {Object} [opts] - command options (optional)\n     * @param {Object} [args] - command arguments (optional)\n     * @returns {Q.Promise}\n     */\n\n  }, {\n    key: \"invoke\",\n    value: function invoke(cmds, opts, args) {\n      var _this5 = this;\n\n      cmds || (cmds = []);\n      opts || (opts = {});\n      args || (args = {});\n      typeof cmds === 'string' && (cmds = cmds.split(' '));\n\n      if (arguments.length < 3 && !Array.isArray(cmds)) {\n        args = opts;\n        opts = cmds;\n        cmds = [];\n      }\n\n      return Q.when(this._parseCmd(cmds), function (p) {\n        if (p.argv.length) return _this5.reject(\"Unknown command: \".concat(cmds.join(' ')));\n        return Q.all([_this5._processParams(opts, _this5._opts), _this5._processParams(args, _this5._args)]).spread(function (_opts, _args) {\n          return _this5._do({\n            cmd: p.cmd,\n            opts: _opts,\n            args: _args\n          }).fail(function (res) {\n            return res && res.exitCode === 0 ? res.toString() : _this5.reject(res);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"api\",\n\n    /**\n     * Returns object containing all its subcommands as methods\n     * to use from other programs.\n     *\n     * @returns {Object}\n     */\n    get: function get() {\n      var _this6 = this;\n\n      // Need _this here because of passed arguments into _api\n      var _this = this;\n\n      this._api || (this._api = function () {\n        return _this.invoke.apply(_this, arguments);\n      });\n      var cmds = this._cmdsByName;\n      Object.keys(cmds).forEach(function (cmd) {\n        _this6._api[cmd] = cmds[cmd].api;\n      });\n      return this._api;\n    }\n  }, {\n    key: \"isRootCmd\",\n    get: function get() {\n      return this._cmd === this;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(cmd) {\n      return new Cmd(cmd);\n    }\n  }]);\n\n  return Cmd;\n}(CoaObject);\n/**\n * Convenient function to run command from tests.\n *\n * @param {String[]} argv - arguments\n * @returns {Q.Promise}\n */\n\n\nCmd.prototype.do = function (argv) {\n  return this._do(this._parseArr(argv || []));\n};\n\nmodule.exports = Cmd;","map":null,"metadata":{},"sourceType":"script"}