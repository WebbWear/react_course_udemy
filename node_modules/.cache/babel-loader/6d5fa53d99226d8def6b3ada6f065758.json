{"ast":null,"code":"'use strict';\n\nvar constants = require('constants');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar Q = require('q');\n\nvar shell = require('./shell');\n\nvar escape = shell.escape;\nvar unescape = shell.unescape;\n/**\n * Most of the code adopted from the npm package shell completion code.\n * See https://github.com/isaacs/npm/blob/master/lib/completion.js\n *\n * @returns {COA.CoaObject}\n */\n\nmodule.exports = function completion() {\n  var _this = this;\n\n  return this.title('Shell completion').helpful().arg().name('raw').title('Completion words').arr().end().act(function (opts, args) {\n    if (process.platform === 'win32') {\n      var e = new Error('shell completion not supported on windows');\n      e.code = 'ENOTSUP';\n      e.errno = constants.ENOTSUP;\n      return _this.reject(e);\n    } // if the COMP_* isn't in the env, then just dump the script\n\n\n    if (process.env.COMP_CWORD == null || process.env.COMP_LINE == null || process.env.COMP_POINT == null) {\n      return dumpScript(_this._cmd._name);\n    }\n\n    console.error('COMP_LINE:  %s', process.env.COMP_LINE);\n    console.error('COMP_CWORD: %s', process.env.COMP_CWORD);\n    console.error('COMP_POINT: %s', process.env.COMP_POINT);\n    console.error('args: %j', args.raw); // completion opts\n\n    opts = getOpts(args.raw); // cmd\n\n    var parsed = _this._cmd._parseCmd(opts.partialWords);\n\n    return Q.when(complete(parsed.cmd, parsed.opts), function (compls) {\n      console.error('filtered: %j', compls);\n      return console.log(compls.map(escape).join('\\n'));\n    });\n  });\n};\n\nfunction dumpScript(name) {\n  var defer = Q.defer();\n  fs.readFile(path.resolve(__dirname, 'completion.sh'), 'utf8', function (err, d) {\n    if (err) return defer.reject(err);\n    d = d.replace(/{{cmd}}/g, path.basename(name)).replace(/^#!.*?\\n/, '');\n    process.stdout.on('error', onError);\n    process.stdout.write(d, function () {\n      return defer.resolve();\n    });\n  });\n  return defer.promise;\n\n  function onError(err) {\n    // Darwin is a real dick sometimes.\n    //\n    // This is necessary because the \"source\" or \".\" program in\n    // bash on OS X closes its file argument before reading\n    // from it, meaning that you get exactly 1 write, which will\n    // work most of the time, and will always raise an EPIPE.\n    //\n    // Really, one should not be tossing away EPIPE errors, or any\n    // errors, so casually. But, without this, `. <(cmd completion)`\n    // can never ever work on OS X.\n    if (err.errno !== constants.EPIPE) return defer.reject(err);\n    process.stdout.removeListener('error', onError);\n    return defer.resolve();\n  }\n}\n\nfunction getOpts(argv) {\n  // get the partial line and partial word, if the point isn't at the end\n  // ie, tabbing at: cmd foo b|ar\n  var line = process.env.COMP_LINE;\n  var w = +process.env.COMP_CWORD;\n  var point = +process.env.COMP_POINT;\n  var words = argv.map(unescape);\n  var word = words[w];\n  var partialLine = line.substr(0, point);\n  var partialWords = words.slice(0, w); // figure out where in that last word the point is\n\n  var partialWord = argv[w] || '';\n  var i = partialWord.length;\n\n  while (partialWord.substr(0, i) !== partialLine.substr(-1 * i) && i > 0) {\n    i--;\n  }\n\n  partialWord = unescape(partialWord.substr(0, i));\n  partialWord && partialWords.push(partialWord);\n  return {\n    line: line,\n    w: w,\n    point: point,\n    words: words,\n    word: word,\n    partialLine: partialLine,\n    partialWords: partialWords,\n    partialWord: partialWord\n  };\n}\n\nfunction complete(cmd, opts) {\n  var optWord,\n      optPrefix,\n      compls = []; // Complete on cmds\n\n  if (opts.partialWord.indexOf('-')) compls = Object.keys(cmd._cmdsByName); // Complete on required opts without '-' in last partial word\n  // (if required not already specified)\n  //\n  // Commented out because of uselessness:\n  // -b, --block suggest results in '-' on cmd line;\n  // next completion suggest all options, because of '-'\n  //.concat Object.keys(cmd._optsByKey).filter (v) -> cmd._optsByKey[v]._req\n  else {\n      // complete on opt values: --opt=| case\n      var m = opts.partialWord.match(/^(--\\w[\\w-_]*)=(.*)$/);\n\n      if (m) {\n        optWord = m[1];\n        optPrefix = optWord + '=';\n      } else // complete on opts\n        // don't complete on opts in case of --opt=val completion\n        // TODO: don't complete on opts in case of unknown arg after commands\n        // TODO: complete only on opts with arr() or not already used\n        // TODO: complete only on full opts?\n        compls = Object.keys(cmd._optsByKey);\n    } // complete on opt values: next arg case\n\n  opts.partialWords[opts.w - 1].indexOf('-') || (optWord = opts.partialWords[opts.w - 1]); // complete on opt values: completion\n\n  var opt;\n  optWord && (opt = cmd._optsByKey[optWord]) && !opt._flag && opt._comp && (compls = Q.join(compls, Q.when(opt._comp(opts), function (c, o) {\n    return c.concat(o.map(function (v) {\n      return (optPrefix || '') + v;\n    }));\n  }))); // TODO: complete on args values (context aware, custom completion?)\n  // custom completion on cmds\n\n  cmd._comp && (compls = Q.join(compls, Q.when(cmd._comp(opts)), function (c, o) {\n    return c.concat(o);\n  })); // TODO: context aware custom completion on cmds, opts and args\n  // (can depend on already entered values, especially options)\n\n  return Q.when(compls, function (complitions) {\n    console.error('partialWord: %s', opts.partialWord);\n    console.error('compls: %j', complitions);\n    return compls.filter(function (c) {\n      return c.indexOf(opts.partialWord) === 0;\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}